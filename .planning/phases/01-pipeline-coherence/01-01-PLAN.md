---
phase: 01-pipeline-coherence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/design/context-provider.ts
  - src/lib/design/types.ts
  - src/lib/design/index.ts
autonomous: true

must_haves:
  truths:
    - "Design context is computed once from brand config and visual style"
    - "Design context contains all visual decisions (colors, typography, spacing)"
    - "Design context interface matches research-specified schema"
  artifacts:
    - path: "src/lib/design/types.ts"
      provides: "DesignContext interface and related types"
      exports: ["DesignContext", "DesignContextInput"]
    - path: "src/lib/design/context-provider.ts"
      provides: "computeDesignContext function"
      exports: ["computeDesignContext"]
    - path: "src/lib/design/index.ts"
      provides: "Public API barrel export"
      exports: ["computeDesignContext", "DesignContext"]
  key_links:
    - from: "src/lib/design/context-provider.ts"
      to: "src/lib/slide-templates/types.ts"
      via: "import design presets"
      pattern: "import.*from.*slide-templates"
---

<objective>
Create the Design Context Provider - a pure function that computes a complete, immutable design context from brand configuration and visual style selection.

Purpose: This is the single source of truth for all visual decisions. Once computed, the design context flows to all downstream components (content generation, background generation, slide compositor) without reinterpretation.

Output: A `computeDesignContext()` function that takes brand visual config + style selection and returns a complete DesignContext object.
</objective>

<execution_context>
@~/.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md

Key reference from research:
```typescript
interface DesignContext {
  visualStyle: 'typography' | 'photorealistic' | 'illustration' | '3d-render' | 'abstract-art' | 'collage';
  primaryColor: string;
  accentColor: string;
  backgroundColor: string;
  fontFamily: string;
  headlineFontSize: number;
  bodyFontSize: number;
  headlineFontWeight: number;
  bodyFontWeight: number;
  paddingX: number;
  paddingY: number;
  masterBrandPrompt?: string;
  aesthetic: string;
}
```

Existing design system: @src/lib/slide-templates/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Design Context Types</name>
  <files>src/lib/design/types.ts</files>
  <action>
Create the type definitions for the Design Context system:

1. Create `src/lib/design/` directory if not exists

2. Define `DesignContext` interface with ALL visual properties:
   - visualStyle: 'typography' | 'photorealistic' | 'illustration' | '3d-render' | 'abstract-art' | 'collage'
   - primaryColor: string (hex, for text)
   - accentColor: string (hex, for highlights)
   - backgroundColor: string (hex)
   - fontFamily: string (always 'Inter' for consistency)
   - headlineFontSize: number (pixels)
   - bodyFontSize: number (pixels)
   - headlineFontWeight: number
   - bodyFontWeight: number
   - paddingX: number (pixels)
   - paddingY: number (pixels)
   - masterBrandPrompt?: string (optional, from brand analysis)
   - aesthetic: string (descriptive, for prompts)

3. Define `DesignContextInput` interface for the input to computeDesignContext:
   - brandVisualConfig?: { primary_color?: string; accent_color?: string; secondary_color?: string; image_style?: string; fonts?: { heading?: string; body?: string }; master_brand_prompt?: string }
   - visualStyle?: string (the selected style)
   - textStyle?: string (optional, maps to TEXT_STYLE_PRESETS)

4. Export both interfaces

Do NOT add runtime code - types only in this file.
  </action>
  <verify>
Run `npx tsc --noEmit src/lib/design/types.ts` - should compile without errors.
  </verify>
  <done>
types.ts exists with DesignContext and DesignContextInput interfaces matching the research spec.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement computeDesignContext Function</name>
  <files>src/lib/design/context-provider.ts</files>
  <action>
Create the core Design Context Provider function:

1. Import types from './types'
2. Import TEXT_STYLE_PRESETS from '@/lib/slide-templates/types'

3. Implement `computeDesignContext(input: DesignContextInput): DesignContext`:

   Priority order for resolving values (highest to lowest):
   a. masterBrandPrompt from brand config (if exists, this drives aesthetic)
   b. Brand colors (primary_color, accent_color from visual_config)
   c. textStyle preset (maps to typography sizing)
   d. visualStyle defaults (each style has sensible defaults)

   Logic:
   - If brand has master_brand_prompt, include it (it's the authoritative brand guide)
   - Resolve colors: brandVisualConfig.primary_color || style-specific default
   - Resolve typography: use TEXT_STYLE_PRESETS[input.textStyle] or 'bold-editorial' default
   - visualStyle determines the aesthetic string and default background approach
   - fontFamily is ALWAYS 'Inter' (consistency)
   - padding is ALWAYS { paddingX: 60, paddingY: 80 } (template constraint)

4. Add helper function `getStyleDefaults(visualStyle: string)` that returns sensible color defaults per style:
   - 'typography': dark bg (#1a1a1a), white text (#ffffff), coral accent (#ff6b6b)
   - 'photorealistic': transparent overlay approach, white text
   - 'illustration': cream bg, navy text, coral accent
   - '3d-render': dark gradient bg, white text, purple accent
   - 'abstract-art': dark bg, white text, coral accent
   - 'collage': off-white bg, dark text, coral accent

5. The function must be PURE - no side effects, no API calls, no database access.

6. Export the function.
  </action>
  <verify>
Write a quick test in the file as a comment block showing expected input/output:
```
// Test: computeDesignContext({ visualStyle: 'typography', brandVisualConfig: { primary_color: '#ff0000' } })
// Expected: { visualStyle: 'typography', accentColor: '#ff0000', primaryColor: '#ffffff', ... }
```
Run `npx tsc --noEmit src/lib/design/context-provider.ts` - should compile.
  </verify>
  <done>
context-provider.ts exports computeDesignContext that takes DesignContextInput and returns a complete DesignContext with all fields populated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Barrel Export and Verify Integration</name>
  <files>src/lib/design/index.ts</files>
  <action>
1. Create barrel export file:
   ```typescript
   export { computeDesignContext } from './context-provider';
   export type { DesignContext, DesignContextInput } from './types';
   ```

2. Verify the module can be imported from other parts of the codebase:
   - The export path should work as `@/lib/design`

3. Add a brief JSDoc comment at the top of index.ts explaining the module's purpose:
   ```
   /**
    * Design Context Provider
    *
    * Single source of truth for all visual decisions in carousel generation.
    * Design context is computed ONCE and flows to all downstream components.
    *
    * Usage:
    *   const context = computeDesignContext({ visualStyle: 'typography', brandVisualConfig: brand.visual_config });
    *   // Pass context to content generation, background generation, and compositor
    */
   ```
  </action>
  <verify>
Run `npm run build` - should pass without errors related to the new design module.
  </verify>
  <done>
The design module is complete with types, implementation, and barrel export. Can be imported as `import { computeDesignContext, DesignContext } from '@/lib/design'`.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npx tsc --noEmit` passes
3. New files exist:
   - src/lib/design/types.ts
   - src/lib/design/context-provider.ts
   - src/lib/design/index.ts
4. DesignContext interface matches research spec (all 12 fields)
5. computeDesignContext is a pure function (no side effects)
</verification>

<success_criteria>
- Design Context Provider module exists at src/lib/design/
- computeDesignContext function takes brand config + style and returns complete DesignContext
- All visual decisions are captured in one object (colors, typography, spacing, aesthetic)
- Function is pure (no API calls, no database access)
- Module exports cleanly via barrel file
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-coherence/01-01-SUMMARY.md`
</output>
