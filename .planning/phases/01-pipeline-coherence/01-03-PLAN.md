---
phase: 01-pipeline-coherence
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/slide-templates/templates.tsx
  - src/lib/slide-templates/types.ts
  - src/lib/slide-templates/index.ts
autonomous: true

must_haves:
  truths:
    - "Templates define layout constraints that AI cannot violate"
    - "All template rendering uses DesignContext directly (no reinterpretation)"
    - "Template functions are pure and deterministic given the same inputs"
  artifacts:
    - path: "src/lib/slide-templates/templates.tsx"
      provides: "Template components that accept DesignContext"
      exports: ["getSlideTemplate"]
    - path: "src/lib/slide-templates/types.ts"
      provides: "Updated types including DesignContext integration"
      contains: "DesignContext"
  key_links:
    - from: "src/lib/slide-templates/templates.tsx"
      to: "src/lib/design/types.ts"
      via: "import DesignContext for strict typing"
      pattern: "import.*DesignContext.*from.*design"
---

<objective>
Enforce template-first architecture by updating slide templates to accept DesignContext directly, removing any opportunity for design reinterpretation.

Purpose: Templates are the authority on layout and design. By requiring DesignContext as input (rather than resolving styles internally), we guarantee that all slides use exactly the same visual properties. This addresses PIPE-03.

Output: Updated template system that enforces design constraints programmatically.
</objective>

<execution_context>
@~/.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md

Current templates: @src/lib/slide-templates/templates.tsx
Current types: @src/lib/slide-templates/types.ts
Design Context: @src/lib/design/types.ts (from Plan 01)

Key principle from research:
"Compositor uses PROGRAMMATIC rendering (Satori + Sharp), NOT AI. This guarantees that typography, colors, and layout are exactly as specified. AI-generated text overlays introduce variation; programmatic compositing eliminates it."
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Template Types for DesignContext Integration</name>
  <files>src/lib/slide-templates/types.ts</files>
  <action>
Update the slide-templates types to integrate with DesignContext:

1. Add import at top: `import type { DesignContext } from '@/lib/design';`

2. Update `CompositeImageRequest` interface to use DesignContext:
   ```typescript
   export interface CompositeImageRequest {
     backgroundImage: string;
     content: SlideContent;
     designContext: DesignContext;  // Changed from designSystem: CarouselDesignSystem
     width: number;
     height: number;
     templateType: 'hook' | 'content' | 'cta' | 'numbered';
   }
   ```

3. Add type alias for backwards compatibility (during migration):
   ```typescript
   // Backwards compatibility - CarouselDesignSystem maps to DesignContext
   // TODO: Remove after all usages migrate to DesignContext
   export type CarouselDesignSystem = Omit<DesignContext, 'visualStyle' | 'masterBrandPrompt'>;
   ```

4. Keep existing SlideContent interface unchanged (it's about content, not design).

5. Keep existing presets (PRESET_DESIGN_SYSTEMS, TEXT_STYLE_PRESETS, TEXT_COLOR_PRESETS) for backwards compatibility, but add deprecation comments:
   ```typescript
   /**
    * @deprecated Use computeDesignContext() from @/lib/design instead.
    * These presets are kept for backwards compatibility during migration.
    */
   export const PRESET_DESIGN_SYSTEMS: Record<string, CarouselDesignSystem> = { ... };
   ```
  </action>
  <verify>
`npx tsc --noEmit src/lib/slide-templates/types.ts` compiles without errors.
  </verify>
  <done>
types.ts imports DesignContext and CompositeImageRequest uses it directly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Template Rendering to Enforce DesignContext</name>
  <files>src/lib/slide-templates/templates.tsx</files>
  <action>
Update the template rendering to use DesignContext directly:

1. Add import: `import type { DesignContext } from '@/lib/design';`

2. Update `getSlideTemplate` function signature:
   ```typescript
   export function getSlideTemplate(
     templateType: 'hook' | 'content' | 'cta' | 'numbered',
     props: {
       content: SlideContent;
       design: DesignContext;  // Changed from CarouselDesignSystem
       width: number;
       height: number;
       hasBackground: boolean;
     }
   ): React.ReactElement
   ```

3. Inside each template component (HookSlide, ContentSlide, CTASlide, NumberedSlide):
   - Use design.primaryColor for text
   - Use design.accentColor for highlights
   - Use design.backgroundColor for fallback bg (when no image)
   - Use design.headlineFontSize, design.bodyFontSize for typography
   - Use design.headlineFontWeight, design.bodyFontWeight for weights
   - Use design.paddingX, design.paddingY for layout
   - Use design.fontFamily (always 'Inter')

4. Remove any internal style resolution logic. The template should NOT:
   - Pick colors based on conditions
   - Adjust font sizes
   - Change padding
   - Make any design decisions

   If it currently does any of these, replace with direct DesignContext property access.

5. Add explicit JSDoc to getSlideTemplate:
   ```typescript
   /**
    * Returns a template component for the given slide type.
    *
    * IMPORTANT: Templates are AUTHORITATIVE on layout. They use DesignContext
    * properties EXACTLY as provided. No interpretation or adjustment.
    *
    * This is a pure function - same inputs always produce same output.
    */
   ```

6. Ensure templates handle the `visualStyle` property from DesignContext (for potential style-specific layout variations, but keep simple initially).
  </action>
  <verify>
`npx tsc --noEmit src/lib/slide-templates/templates.tsx` compiles without errors.
  </verify>
  <done>
templates.tsx uses DesignContext directly with no internal design decisions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Barrel Export and Add Template Constraints Documentation</name>
  <files>src/lib/slide-templates/index.ts</files>
  <action>
1. Read existing src/lib/slide-templates/index.ts

2. Update exports to include DesignContext re-export for convenience:
   ```typescript
   // Re-export DesignContext for template consumers
   export type { DesignContext } from '@/lib/design';
   ```

3. Add a doc comment at the top explaining the template-first architecture:
   ```typescript
   /**
    * Slide Templates Module
    *
    * Templates define LOCKED layout constraints for carousel slides.
    * They accept a DesignContext and apply it exactly as specified.
    *
    * Key principles:
    * 1. Templates are AUTHORITATIVE - they define what's possible
    * 2. DesignContext is IMMUTABLE - computed once, used everywhere
    * 3. No interpretation - colors, fonts, sizes used exactly as provided
    *
    * Usage:
    *   const context = computeDesignContext({ ... });
    *   const template = getSlideTemplate('hook', { content, design: context, ... });
    */
   ```

4. Keep all existing exports for backwards compatibility.
  </action>
  <verify>
`npm run build` passes.
  </verify>
  <done>
Barrel export updated with DesignContext re-export and architectural documentation.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npm run lint` passes (or no new errors)
3. getSlideTemplate accepts DesignContext (not just CarouselDesignSystem)
4. Templates use design properties directly without internal resolution
5. CompositeImageRequest interface updated to use DesignContext
6. Backwards compatibility maintained via type alias
</verification>

<success_criteria>
- Templates accept DesignContext directly
- No design decisions made inside templates (pure rendering)
- All slides rendered with identical design system properties
- Backwards compatibility maintained during migration
- Template module documents the template-first architecture
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-coherence/01-03-SUMMARY.md`
</output>
