---
phase: 01-pipeline-coherence
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/app/api/content/carousel/route.ts
  - src/app/api/images/carousel/route.ts
autonomous: true

must_haves:
  truths:
    - "Carousel content is generated using the new all-at-once prompt system"
    - "Design context is computed once and passed to all components"
    - "Image generation receives the same DesignContext that content generation used"
  artifacts:
    - path: "src/app/api/content/carousel/route.ts"
      provides: "Dedicated carousel content generation endpoint"
      exports: ["POST"]
    - path: "src/app/api/images/carousel/route.ts"
      provides: "Updated image carousel endpoint using DesignContext"
      contains: "computeDesignContext"
  key_links:
    - from: "src/app/api/content/carousel/route.ts"
      to: "src/lib/design/context-provider.ts"
      via: "compute design context"
      pattern: "computeDesignContext"
    - from: "src/app/api/content/carousel/route.ts"
      to: "src/lib/prompts/carousel-prompt.ts"
      via: "use carousel prompts"
      pattern: "CAROUSEL_SYSTEM_PROMPT"
    - from: "src/app/api/images/carousel/route.ts"
      to: "src/lib/design/context-provider.ts"
      via: "receive or compute design context"
      pattern: "DesignContext"
---

<objective>
Wire the Design Context Provider and carousel prompt system into the API routes, completing the coherent pipeline.

Purpose: This plan connects all the pieces built in Plans 01-03. The content generation endpoint uses the all-at-once carousel prompt. The image generation endpoint receives the same DesignContext. This ensures visual and narrative coherence across the entire pipeline.

Output: Working API endpoints that generate coherent carousels using the new architecture.
</objective>

<execution_context>
@~/.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md

Design Context: @src/lib/design/index.ts (from Plan 01)
Carousel Prompts: @src/lib/prompts/carousel-prompt.ts (from Plan 02)
Templates: @src/lib/slide-templates/templates.tsx (from Plan 03)
Current carousel route: @src/app/api/images/carousel/route.ts
Current content route: @src/app/api/content/generate/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dedicated Carousel Content Generation Endpoint</name>
  <files>src/app/api/content/carousel/route.ts</files>
  <action>
Create a new endpoint specifically for carousel content generation using the all-at-once approach:

1. Create directory `src/app/api/content/carousel/` if not exists

2. Create route.ts with POST handler:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getAnthropicClient, DEFAULT_MODEL, extractTextContent } from '@/lib/anthropic/client';
import { computeDesignContext, type DesignContext } from '@/lib/design';
import {
  CAROUSEL_SYSTEM_PROMPT,
  buildCarouselUserPrompt,
  type CarouselGenerationResult,
} from '@/lib/prompts';
import { buildVoicePrompt, type VoiceConfig } from '@/lib/prompts';

export async function POST(request: NextRequest) {
  // 1. Parse request body
  const body = await request.json();
  const { ideaId, visualStyle, textStyle } = body;

  // 2. Fetch idea with brand config
  const supabase = await createClient();
  const { data: idea, error } = await supabase
    .from('ideas')
    .select('*, inputs(*), brands(*)')
    .eq('id', ideaId)
    .single();

  if (error || !idea) {
    return NextResponse.json({ error: 'Idea not found' }, { status: 404 });
  }

  // 3. COMPUTE DESIGN CONTEXT ONCE
  const brandVisualConfig = idea.brands?.visual_config;
  const designContext = computeDesignContext({
    visualStyle: visualStyle || 'typography',
    textStyle: textStyle || 'bold-editorial',
    brandVisualConfig,
  });

  // 4. Build voice prompt
  const voiceConfig = idea.brands?.voice_config as VoiceConfig | null;
  const brandVoicePrompt = buildVoicePrompt(voiceConfig, brandVisualConfig);

  // 5. Build carousel user prompt (includes design context awareness)
  const userPrompt = buildCarouselUserPrompt(
    {
      concept: idea.concept,
      angle: idea.angle,
      keyPoints: idea.key_points || [],
      potentialHooks: idea.potential_hooks || [],
    },
    idea.inputs?.raw_content || 'No source content',
    designContext,
    brandVoicePrompt
  );

  // 6. Call Claude with carousel system prompt
  const anthropic = getAnthropicClient();
  const message = await anthropic.messages.create({
    model: DEFAULT_MODEL,
    max_tokens: 4096,
    system: CAROUSEL_SYSTEM_PROMPT,
    messages: [{ role: 'user', content: userPrompt }],
  });

  // 7. Parse response
  const responseText = extractTextContent(message);
  let result: CarouselGenerationResult;
  try {
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error('No JSON in response');
    result = JSON.parse(jsonMatch[0]);
  } catch (parseError) {
    console.error('Parse error:', parseError, 'Response:', responseText);
    return NextResponse.json({ error: 'Failed to parse AI response' }, { status: 500 });
  }

  // 8. Save to database with design context in metadata
  const contentToInsert = {
    idea_id: ideaId,
    brand_id: idea.brand_id,
    platform: 'instagram',
    copy_primary: result.caption,
    copy_hashtags: result.hashtags,
    copy_cta: result.cta,
    copy_carousel_slides: result.slides.map(slide => JSON.stringify(slide)),
    status: 'draft',
    metadata: {
      visualStyle,
      textStyle,
      designContext,  // STORE THE DESIGN CONTEXT
      narrativeArc: result.narrativeArc,
      generatedWith: 'carousel-v2',
    },
  };

  const { data: savedContent, error: saveError } = await supabase
    .from('content')
    .insert(contentToInsert)
    .select()
    .single();

  if (saveError) {
    console.error('Save error:', saveError);
    return NextResponse.json({ error: 'Failed to save content' }, { status: 500 });
  }

  // 9. Return result with design context for downstream use
  return NextResponse.json({
    success: true,
    content: savedContent,
    designContext,  // RETURN FOR IMMEDIATE IMAGE GENERATION
    narrativeArc: result.narrativeArc,
  });
}
```

Key points:
- Design context computed ONCE at step 3
- Design context stored in metadata for reproducibility
- Design context returned for downstream image generation
- Uses CAROUSEL_SYSTEM_PROMPT (all-at-once generation)
  </action>
  <verify>
`npx tsc --noEmit src/app/api/content/carousel/route.ts` compiles.
  </verify>
  <done>
New /api/content/carousel endpoint exists that computes DesignContext once and uses all-at-once carousel generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Image Carousel Route to Accept DesignContext</name>
  <files>src/app/api/images/carousel/route.ts</files>
  <action>
Update the existing carousel image generation route to accept and use DesignContext:

1. Add import: `import { computeDesignContext, type DesignContext } from '@/lib/design';`

2. Update the request body parsing to accept designContext:
   ```typescript
   const {
     contentId,
     slides,
     designContext: providedDesignContext,  // NEW: Accept pre-computed context
     // Keep existing params for backwards compatibility
     designPreset,
     textStyle,
     textColor,
     backgroundStyle,
     visualStyle,
     // ... rest
   } = body;
   ```

3. Update design resolution logic (around line 550-590):
   ```typescript
   // Priority: providedDesignContext > compute from params > legacy presets
   let design: DesignContext;

   if (providedDesignContext && typeof providedDesignContext === 'object') {
     // Use the pre-computed DesignContext (preferred path)
     design = providedDesignContext as DesignContext;
     console.log('Using provided DesignContext');
   } else {
     // Fallback: compute from request params
     design = computeDesignContext({
       visualStyle: visualStyle || 'typography',
       textStyle: textStyle || 'bold-editorial',
       brandVisualConfig: typedBrandColors,
     });
     console.log('Computed DesignContext from params');
   }
   ```

4. Update the compositeSlide call to use DesignContext:
   - The compositeSlide function already accepts a design parameter
   - Ensure it's typed as DesignContext (may need minor type adjustment)

5. Update the response to include the design context used:
   ```typescript
   return NextResponse.json({
     success: true,
     images: generatedImages,
     design: {
       context: design,  // Return the actual DesignContext used
       preset: typeof designPreset === 'string' ? designPreset : 'computed',
     },
     // ... rest
   });
   ```

6. Keep all backwards compatibility - existing callers without designContext should still work.
  </action>
  <verify>
`npm run build` passes. The endpoint accepts both old params and new designContext.
  </verify>
  <done>
/api/images/carousel accepts pre-computed DesignContext and uses it for all slides.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Integration Logging for Pipeline Verification</name>
  <files>src/app/api/content/carousel/route.ts, src/app/api/images/carousel/route.ts</files>
  <action>
Add logging to verify the design context flows correctly through the pipeline:

1. In /api/content/carousel/route.ts, add after computing design context:
   ```typescript
   console.log('[Carousel Content] Design context computed:', {
     visualStyle: designContext.visualStyle,
     primaryColor: designContext.primaryColor,
     accentColor: designContext.accentColor,
     aesthetic: designContext.aesthetic,
   });
   ```

2. In /api/images/carousel/route.ts, add after resolving design:
   ```typescript
   console.log('[Carousel Images] Design context resolved:', {
     source: providedDesignContext ? 'provided' : 'computed',
     visualStyle: design.visualStyle,
     primaryColor: design.primaryColor,
     accentColor: design.accentColor,
   });
   ```

3. In compositeSlide function (or before calling it), add:
   ```typescript
   console.log(`[Slide ${slideNumber}] Compositing with design:`, {
     primaryColor: design.primaryColor,
     headlineFontSize: design.headlineFontSize,
   });
   ```

These logs help verify:
- Design context is computed once
- Same values flow to image generation
- All slides use identical design properties
  </action>
  <verify>
Manually trigger a carousel generation and check logs show consistent design context across all steps.
  </verify>
  <done>
Pipeline has logging to verify design context consistency.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npm run lint` passes (or no new errors)
3. New endpoint exists: POST /api/content/carousel
4. Existing endpoint updated: POST /api/images/carousel accepts designContext
5. Design context is computed once in content generation
6. Design context is passed to (or stored for) image generation
7. Logs show consistent design values across pipeline
</verification>

<success_criteria>
- Carousel content generation uses all-at-once prompt
- Design context computed once and flows through entire pipeline
- Image generation uses the SAME design context as content generation
- Backwards compatibility maintained for existing callers
- Pipeline logging verifies consistency
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-coherence/01-04-SUMMARY.md`
</output>
